import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of, BehaviorSubject } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { environment } from 'src/environments/environment';

export interface EmployeeTransfer {
  transferId?: string;  // Made optional as it's generated by the backend
  empId: string;
  transferTypeId: string;
  initiatedBy: string;
  initiationDate: string;
  effectiveDate: string;
  fromBranchId: string;
  fromDeptId: string;
  fromPositionId: string;
  fromManagerId: string;
  toBranchId: string;
  toDeptId: string;
  toPositionId: string;
  toManagerId: string;
  transferReason: string;
  employeeConsent: boolean;
  consentDate: string;
  relocationAllowance: number;
  transferStatus: string;
  approvedBy: string | null;
  approvalDate: string | null;
  rejectionReason: string | null;
  isTemporary: boolean;
  temporaryEndDate: string | null;
  probationApplicable: boolean;
  probationEndDate: string | null;
  createdDate: string;
  modifiedDate: string;
}

interface TransferResponse {
  message: string;
  data: EmployeeTransfer[];
}

export interface TransferType {
  transferTypeId: string;
  orgId: string;
  transferName: string;
  transferCode: string;
  category: string;
  requiresConsent: boolean;
  hasProbation: boolean;
  probationDays: number;
  createdDate: string;
}

interface TransferTypeResponse {
  message: string;
  data: TransferType;
}

export interface EmployeeProfile {
  empId: string;
  firstName: string;
  middleName: string | null;
  lastName: string;
  // Other fields as needed
}

export interface EmployeeProfileResponse {
  employee: EmployeeProfile;
  // Other fields as needed
}

@Injectable({
  providedIn: 'root'
})
export class EmployeeTransferService {
  private apiUrl = `${environment.transferApiUrl}/employeetransfer`;
  private transferTypeBaseUrl = `${environment.transferApiUrl}`; // New base URL for transfer types
  private transferTypesCache: {[key: string]: TransferType} = {};

  private employeeCache: {[key: string]: EmployeeProfile} = {};
  private loadingSubject = new BehaviorSubject<boolean>(false);
  public isLoading$ = this.loadingSubject.asObservable();

  constructor(private http: HttpClient) { }

  private setLoading(isLoading: boolean): void {
    this.loadingSubject.next(isLoading);
  }

  /**
   * Get all employee transfers
   * @returns Observable containing the list of employee transfers
   */
  getAllTransfers(): Observable<TransferResponse> {
    return this.http.get<TransferResponse>(this.apiUrl);
  }

  /**
   * Get employee profiles
   * @returns Observable containing the list of employee profiles
   */
  getEmployeeProfiles(): Observable<EmployeeProfileResponse[]> {
    this.setLoading(true);
    return this.http.get<EmployeeProfileResponse[]>(`${environment.apiUrl}/employees`).pipe(
      tap(() => this.setLoading(false)),
      catchError(error => {
        this.setLoading(false);
        return of([]);
      })
    );
  }

  /**
   * Get departments from the API
   */
  getDepartments() {
    return this.http.get<any[]>(`${environment.apiUrl}/departments`);
  }

  /**
   * Get branches from the API
   */
  getBranches() {
    return this.http.get<any[]>(`${environment.apiUrl}/api/v1/branches`);
  }

  /**
   * Get job positions from the API
   */
  getJobPositions() {
    return this.http.get<any[]>(`${environment.apiUrl}/api/v1/job-positions`);
  }

  /**
   * Get all employees from the API
   */
  getEmployees() {
    return this.http.get<any[]>(`${environment.apiUrl}/api/v1/employees`);
  }

  /**
   * Get transfer type by ID
   * @param transferTypeId The ID of the transfer type to fetch
   * @returns Observable containing the transfer type details
   */
  /**
   * Get employee profile by ID
   * @param empId Employee ID
   * @returns Observable containing the employee profile
   */
  /**
   * Create a new employee transfer
   * @param transferData The transfer data to be submitted
   * @returns Observable containing the created transfer
   */
  /**
   * Create a new employee transfer
   * @param transferData The transfer data to submit
   * @returns Observable with the created transfer
   */
  createTransfer(transferData: Partial<EmployeeTransfer>): Observable<EmployeeTransfer> {
    // Create a clean payload with only the fields we want to send
    const payload = {
      empId: transferData.empId,
      transferTypeId: transferData.transferTypeId,
      fromDeptId: transferData.fromDeptId,
      fromBranchId: transferData.fromBranchId,
      fromPositionId: transferData.fromPositionId,
      fromManagerId: transferData.fromManagerId,
      toDeptId: transferData.toDeptId,
      toBranchId: transferData.toBranchId,
      toPositionId: transferData.toPositionId,
      toManagerId: transferData.toManagerId,
      transferReason: transferData.transferReason,
      effectiveDate: transferData.effectiveDate,
      transferStatus: transferData.transferStatus || 'Pending',
      isTemporary: transferData.isTemporary || false,
      temporaryEndDate: transferData.temporaryEndDate,
      probationApplicable: transferData.probationApplicable || false,
      probationEndDate: transferData.probationEndDate,
      employeeConsent: transferData.employeeConsent || false,
      consentDate: transferData.consentDate,
      relocationAllowance: transferData.relocationAllowance || 0,
      initiatedBy: transferData.initiatedBy,
      initiationDate: transferData.initiationDate,
      createdDate: transferData.createdDate,
      modifiedDate: transferData.modifiedDate
    };

    return this.http.post<EmployeeTransfer>(this.apiUrl, payload).pipe(
      catchError(error => {
        throw error; // Re-throw to allow component to handle the error
      })
    );
  }

  getEmployeeProfile(empId: string): Observable<EmployeeProfile> {
    if (this.employeeCache[empId]) {
      return of(this.employeeCache[empId]);
    }

    const url = `${environment.apiUrl}/api/v1/employees/${empId}`;
    
    return this.http.get<EmployeeProfileResponse>(url).pipe(
      map(response => {
        if (response && response.employee) {
          this.employeeCache[response.employee.empId] = response.employee;
          return response.employee;
        }
        throw new Error('Invalid employee data');
      }),
      catchError(error => {
        console.error('Error fetching employee profile:', error);
        return of({
          empId,
          firstName: 'Unknown',
          middleName: null,
          lastName: 'Employee'
        });
      })
    );
  }

  getTransferTypeById(transferTypeId: string): Observable<TransferType> {
    // Check cache first
    if (this.transferTypesCache[transferTypeId]) {
      return of(this.transferTypesCache[transferTypeId]);
    }
    
    return this.http.get<{data: TransferType}>(`${this.transferTypeBaseUrl}/Transfer/${transferTypeId}`).pipe(
      map(response => response.data),
      tap(transferType => {
        // Cache the result
        this.transferTypesCache[transferTypeId] = transferType;
      }),
      catchError(error => {
        console.error('Error fetching transfer type:', error);
        throw error;
      })
    );
  }

  /**
   * Delete a transfer type by ID
   * @param transferTypeId The ID of the transfer type to delete
   * @returns Observable indicating success or failure
   */
  deleteTransferType(transferTypeId: string): Observable<{message: string}> {
    return this.http.delete<{message: string}>(`${this.transferTypeBaseUrl}/Transfer/${transferTypeId}`).pipe(
      tap(() => {
        // Remove from cache if it exists
        if (this.transferTypesCache[transferTypeId]) {
          delete this.transferTypesCache[transferTypeId];
        }
      }),
      catchError(error => {
        console.error('Error deleting transfer type:', error);
        throw error;
      })
    );
  }

  /**
   * Create a new transfer type
   * @param transferType The transfer type data to create
   * @returns Observable containing the created transfer type
   */
  createTransferType(transferType: Omit<TransferType, 'transferTypeId' | 'createdDate'>): Observable<TransferType> {
    console.log('Sending transfer type data to API:', transferType);
    
    return this.http.post<TransferType>(
      `${this.transferTypeBaseUrl}/Transfer`,
      transferType,
      {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      }
    ).pipe(
      tap(createdType => {
        console.log('Transfer type created successfully:', createdType);
        // Add to cache
        if (createdType && createdType.transferTypeId) {
          this.transferTypesCache[createdType.transferTypeId] = createdType;
        }
      }),
      catchError(error => {
        console.error('Error creating transfer type:', error);
        if (error.error) {
          console.error('Error details:', error.error);
        }
        throw error;
      })
    );
  }

  /**
   * Update an existing transfer type
   * @param transferType The updated transfer type data
   * @returns Observable containing the updated transfer type
   */
  updateTransferType(transferType: TransferType): Observable<TransferType> {
    console.log('Updating transfer type:', transferType);
    
    return this.http.put<TransferType>(
      `${this.transferTypeBaseUrl}/Transfer/${transferType.transferTypeId}`,
      transferType,
      {
        headers: {
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        }
      }
    ).pipe(
      tap(updatedType => {
        console.log('Transfer type updated successfully:', updatedType);
        // Update cache
        if (updatedType && updatedType.transferTypeId) {
          this.transferTypesCache[updatedType.transferTypeId] = updatedType;
        }
      }),
      catchError(error => {
        console.error('Error updating transfer type:', error);
        if (error.error) {
          console.error('Error details:', error.error);
        }
        throw error;
      })
    );
  }

  /**
   * Get all transfer types from the API
   * @returns Observable containing the list of transfer types
   */
  getTransferTypes(): Observable<TransferType[]> {
    const url = `${this.transferTypeBaseUrl}/Transfer`;
    
    return this.http.get<{message: string, data: TransferType[]}>(url).pipe(
      map(response => {
        if (!response || !response.data || !Array.isArray(response.data)) {
          throw new Error('Invalid response format: expected data array');
        }
        
        const transferTypes = response.data;
        
        // Cache all transfer types
        transferTypes.forEach(type => {
          if (type && type.transferTypeId) {
            this.transferTypesCache[type.transferTypeId] = type;
          }
        });
        
        return transferTypes;
      }),
      catchError(error => {
        console.error('Error fetching transfer types:', error);
        return of([]);
      })
    );
  }
}