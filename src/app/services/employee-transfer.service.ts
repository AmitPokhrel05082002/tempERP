import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, of, BehaviorSubject, throwError } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';
import { environment } from 'src/environments/environment';

export interface EmployeeTransfer {
  transferId?: string;  // Made optional as it's generated by the backend
  empId: string;
  transferTypeId: string;
  initiatedBy: string;
  initiationDate: string;
  effectiveDate: string;
  fromBranchId: string;
  fromDeptId: string;
  fromPositionId: string;
  fromManagerId: string;
  toBranchId: string;
  toDeptId: string;
  toPositionId: string;
  toManagerId: string;
  transferReason: string;
  employeeConsent: boolean;
  consentDate: string;
  relocationAllowance: number;
  transferStatus: string;
  approvedBy: string | null;
  approvalDate: string | null;
  rejectionReason: string | null;
  isTemporary: boolean;
  temporaryEndDate: string | null;
  probationApplicable: boolean;
  probationEndDate: string | null;
  createdDate: string;
  modifiedDate: string;
}

interface TransferResponse {
  message: string;
  data: EmployeeTransfer[];
}

export interface TransferType {
  transferTypeId: string;
  orgId: string;
  transferName: string;
  transferCode: string;
  category: string;
  requiresConsent: boolean;
  hasProbation: boolean;
  probationDays: number;
  createdDate: string;
}

interface TransferTypeResponse {
  message: string;
  data: TransferType;
}

export interface EmployeeProfile {
  empId: string;
  firstName: string;
  middleName: string | null;
  lastName: string;
  cidNumber: string | null;
  // Other fields as needed
  dateOfBirth?: string | null;
  gender?: string;
  email?: string;
  phoneNumber?: string;
  department?: string;
  position?: string;
  hireDate?: string | null;
  employmentStatus?: string;
  profileImage?: string | null;
}

export interface EmployeeProfileResponse {
  employee: EmployeeProfile;
  // Other fields as needed
}

@Injectable({
  providedIn: 'root'
})
export class EmployeeTransferService {
  private apiUrl = `${environment.transferApiUrl}/employeetransfer`;
  private transferTypeBaseUrl = `${environment.transferApiUrl}`; // New base URL for transfer types
  private transferTypesCache: {[key: string]: TransferType} = {};

  private employeeCache: {[key: string]: EmployeeProfile} = {};
  private loadingSubject = new BehaviorSubject<boolean>(false);
  public isLoading$ = this.loadingSubject.asObservable();

  constructor(private http: HttpClient) { }

  private setLoading(isLoading: boolean): void {
    this.loadingSubject.next(isLoading);
  }

  /**
   * Get all employee transfers
   * @returns Observable containing the list of employee transfers
   */
  getAllTransfers(): Observable<EmployeeTransfer[]> {
    this.setLoading(true);
    return this.http.get<EmployeeTransfer[]>(this.apiUrl).pipe(
      tap(() => this.setLoading(false)),
      catchError(error => {
        this.setLoading(false);
        console.error('Error fetching transfers:', error);
        return of([]);
      })
    );
  }

  /**
   * Get employee profiles
   * @returns Observable containing the list of employee profiles
   */
  getEmployeeProfiles(): Observable<EmployeeProfileResponse[]> {
    this.setLoading(true);
    return this.http.get<EmployeeProfileResponse[]>(`${environment.apiUrl}/employees`).pipe(
      tap(() => this.setLoading(false)),
      catchError(error => {
        this.setLoading(false);
        return of([]);
      })
    );
  }

  /**
   * Get departments from the API
   */
  getDepartments() {
    return this.http.get<any[]>(`${environment.apiUrl}/departments`);
  }

  /**
   * Get branches from the API
   */
  getBranches() {
    return this.http.get<any[]>(`${environment.apiUrl}/api/v1/branches`);
  }

  /**
   * Get job positions from the API
   */
  getJobPositions() {
    return this.http.get<any[]>(`${environment.apiUrl}/api/v1/job-positions`);
  }

  /**
   * Get all employees from the API
   */
  getEmployees() {
    return this.http.get<any[]>(`${environment.apiUrl}/api/v1/employees`);
  }

  /**
   * Get transfer type by ID
   * @param transferTypeId The ID of the transfer type to fetch
   * @returns Observable containing the transfer type details
   */
  /**
   * Get employee profile by ID
   * @param empId Employee ID
   * @returns Observable containing the employee profile
   */
  /**
   * Create a new employee transfer
   * @param transferData The transfer data to be submitted
   * @returns Observable containing the created transfer
   */
  /**
   * Create a new employee transfer
   * @param transferData The transfer data to submit
   * @returns Observable with the created transfer
   */
  createTransfer(transferData: Partial<EmployeeTransfer>): Observable<EmployeeTransfer> {
    // Create a clean payload with only the fields we want to send
    const payload = {
      empId: transferData.empId,
      transferTypeId: transferData.transferTypeId,
      fromDeptId: transferData.fromDeptId,
      fromBranchId: transferData.fromBranchId,
      fromPositionId: transferData.fromPositionId,
      fromManagerId: transferData.fromManagerId,
      toDeptId: transferData.toDeptId,
      toBranchId: transferData.toBranchId,
      toPositionId: transferData.toPositionId,
      toManagerId: transferData.toManagerId,
      transferReason: transferData.transferReason,
      effectiveDate: transferData.effectiveDate,
      transferStatus: transferData.transferStatus || 'Pending',
      isTemporary: transferData.isTemporary || false,
      temporaryEndDate: transferData.temporaryEndDate,
      probationApplicable: transferData.probationApplicable || false,
      probationEndDate: transferData.probationEndDate,
      employeeConsent: transferData.employeeConsent || false,
      consentDate: transferData.consentDate,
      relocationAllowance: transferData.relocationAllowance || 0,
      initiatedBy: transferData.initiatedBy,
      initiationDate: transferData.initiationDate,
      createdDate: transferData.createdDate,
      modifiedDate: transferData.modifiedDate
    };

    return this.http.post<EmployeeTransfer>(this.apiUrl, payload).pipe(
      catchError(error => {
        throw error; // Re-throw to allow component to handle the error
      })
    );
  }

  getEmployeeProfile(empId: string): Observable<EmployeeProfile> {
    if (this.employeeCache[empId]) {
      return of(this.employeeCache[empId]);
    }

    const url = `${environment.apiUrl}/api/v1/employees/${empId}`;

    return this.http.get<EmployeeProfileResponse>(url).pipe(
      map(response => {
        if (response && response.employee) {
          const employee = response.employee;
          // Ensure all required fields are present
          const profile: EmployeeProfile = {
            empId: employee.empId,
            firstName: employee.firstName || 'Unknown',
            middleName: employee.middleName || null,
            lastName: employee.lastName || 'Employee',
            cidNumber: employee.cidNumber || null,
            dateOfBirth: employee.dateOfBirth || null,
            gender: employee.gender || '',
            email: employee.email || '',
            phoneNumber: employee.phoneNumber || '',
            department: employee.department || '',
            position: employee.position || '',
            hireDate: employee.hireDate || null,
            employmentStatus: employee.employmentStatus || '',
            profileImage: employee.profileImage || null
          };
          this.employeeCache[employee.empId] = profile;
          return profile;
        }
        throw new Error('Invalid employee data');
      }),
      catchError(error => {
        console.error('Error fetching employee profile:', error);
        // Return a default profile with required fields when there's an error
        const defaultProfile: EmployeeProfile = {
          empId,
          firstName: 'Unknown',
          middleName: null,
          lastName: 'Employee',
          cidNumber: null,
          dateOfBirth: null,
          gender: '',
          email: '',
          phoneNumber: '',
          department: '',
          position: '',
          hireDate: null,
          employmentStatus: '',
          profileImage: null
        };
        return of(defaultProfile);
      })
    );
  }

  getTransferTypeById(transferTypeId: string): Observable<TransferType> {
    // Check cache first
    if (this.transferTypesCache[transferTypeId]) {
      return of(this.transferTypesCache[transferTypeId]);
    }

    return this.http.get<TransferType>(`${this.transferTypeBaseUrl}/Transfer/${transferTypeId}`).pipe(
      tap(transferType => {
        // Cache the result
        this.transferTypesCache[transferTypeId] = transferType;
      }),
      catchError(error => {
        console.error('Error fetching transfer type:', error);
        throw error;
      })
    );
  }

  /**
   * Create a new transfer type
   * @param transferType The transfer type data to create
   * @returns Observable containing the created transfer type
   */
  createTransferType(transferType: Omit<TransferType, 'transferTypeId' | 'createdDate'>): Observable<TransferType> {
    const url = `${this.transferTypeBaseUrl}/transferType`;

    // Prepare the request payload with the correct structure
    const payload = {
      orgId: transferType.orgId,
      transferName: transferType.transferName,
      transferCode: transferType.transferCode,
      category: transferType.category,
      requiresConsent: transferType.requiresConsent,
      hasProbation: transferType.hasProbation,
      probationDays: transferType.probationDays
    };

    return this.http.post<TransferType>(url, payload).pipe(
      tap(createdType => {
        // Add to cache
        if (createdType?.transferTypeId) {
          this.transferTypesCache[createdType.transferTypeId] = createdType;
        }
      }),
      catchError(error => {
        console.error('Error creating transfer type:', error);
        throw error;
      })
    );
  }



  /**
   * Delete a transfer type by ID
   * @param transferTypeId The ID of the transfer type to delete
   * @returns Observable indicating success or failure
   */
  deleteTransferType(transferTypeId: string): Observable<{message: string}> {
    return this.http.delete<{message: string}>(`${this.transferTypeBaseUrl}/transferType/${transferTypeId}`).pipe(
      tap(() => {
        // Remove from cache if it exists
        if (this.transferTypesCache[transferTypeId]) {
          delete this.transferTypesCache[transferTypeId];
        }
      }),
      catchError(error => {
        console.error('Error deleting transfer type:', error);
        throw error;
      })
    );
  }

  /**
   * Update an existing transfer type
   * @param transferType The transfer type data to update
   * @returns Observable containing the updated transfer type
   */
  updateTransferType(transferType: TransferType): Observable<TransferType> {
    if (!transferType.transferTypeId) {
      return throwError(() => new Error('Transfer type ID is required for update'));
    }

    const url = `${this.transferTypeBaseUrl}/transferType`;

    // Prepare the request payload with the correct structure
    const payload = {
      transferTypeId: transferType.transferTypeId,
      orgId: transferType.orgId,
      transferName: transferType.transferName,
      transferCode: transferType.transferCode,
      category: transferType.category,
      requiresConsent: transferType.requiresConsent,
      hasProbation: transferType.hasProbation,
      probationDays: transferType.probationDays,
      createdDate: transferType.createdDate
    };

    return this.http.put<TransferType>(url, payload).pipe(
      tap(updatedType => {
        // Update cache
        if (updatedType?.transferTypeId) {
          this.transferTypesCache[updatedType.transferTypeId] = updatedType;
        }
      }),
      catchError(error => {
        console.error('Error updating transfer type:', error);
        if (error.error) {
          console.error('Error details:', error.error);
        }
        throw error;
      })
    );
  }

  /**
   * Get all transfer types from the API
   * @returns Observable containing the list of transfer types
   */
  getTransferTypes(): Observable<TransferType[]> {
    const url = `${this.transferTypeBaseUrl}/transferType`;

    return this.http.get<TransferType[]>(url).pipe(
      map(transferTypes => {
        if (!Array.isArray(transferTypes)) {
          throw new Error('Invalid response format: expected array of transfer types');
        }

        // Cache all transfer types
        transferTypes.forEach(type => {
          if (type && type.transferTypeId) {
            this.transferTypesCache[type.transferTypeId] = type;
          }
        });

        return transferTypes;
      }),
      catchError(error => {
        console.error('Error fetching transfer types:', error);
        return of([]);
      })
    );
  }
}
